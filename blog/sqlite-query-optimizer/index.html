<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  
  <meta name="description" content="An assortment of my ramblings and random adventures." />
  
  

  <title>Micah&#x27;s Secret Blog</title>

  
  <link rel="alternate" type="application/atom+xml" title="RSS" href="https://micahkepe.com/blog/atom.xml">
  

  
  <link rel="stylesheet" href="https://micahkepe.com/blog/site.css">
  

  
  
</head>

<body class="hack dark main container">
  
    
        
  
  <header class="nav-header">
    <nav itemscope itemtype="http://schema.org/SiteNavigationElement" class="navbar">
      <div class="nav-links">
        
        <a itemprop="url"
          class=""
          href="https://micahkepe.com/blog/">
          <span itemprop="name">Home</span></a>
        
        <a itemprop="url"
          class=""
          href="https://micahkepe.com/blog/categories">
          <span itemprop="name">Categories</span></a>
        
        <a itemprop="url"
          class=""
          href="https://micahkepe.com/blog/tags">
          <span itemprop="name">Tags</span></a>
        
        <a itemprop="url"
          class=""
          href="https://micahkepe.com/blog/categories/programming/atom.xml">
          <span itemprop="name">RSS Feed</span></a>
        
        <a itemprop="url"
          class=""
          href="https://micahkepe.com/">
          <span itemprop="name">Main Site</span></a>
        
      </div>
    </nav>
    

  </header>
  
  
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">[10] A Deep Dive into SQLite&#x27;s Query Optimizer</h1>
        <span class="muted">
    <svg class="icon i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>17 minute read</span>
    <svg class="icon i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2024-08-27
</span>
    </header>
    <div itemprop="articleBody">
      <p>I <strong>love</strong> databases, but they are still largely a magical black box to me, so in this post, I'm going to explore how SQLite's query optimizer works. We'll delve together into the process of how SQL queries are parsed, optimized, and executed, with a particular focus on the optimization phase. By the end of this post, you'll have a better understanding of how SQLite's query optimizer works and how it can help you write more efficient queries.</p>
<span id="continue-reading"></span>
<p>This past summer, I got a lot of practice learning the ins and outs of SQLite as part of a project that I have been contributing to, which we originally set up with a SQLite database. I've been working with SQLite for a while now, and I've come to appreciate its simplicity and ease of use.</p>
<h2 id="what-actually-happens-when-you-run-a-query">What Actually Happens When You Run a Query?</h2>
<p>Regardless of the database engine you're using, when you run a query, the database engine goes through a series of steps to execute the query. These steps include:</p>
<ol>
<li><strong>Writing</strong>: The query is written and sent to the database engine.</li>
<li><strong>Parsing</strong>: The query is parsed to ensure it is syntactically correct.</li>
<li><strong>Planning</strong>: The query planner generates an execution plan for the query.</li>
<li><strong>Execution</strong>: The query is actually executed and the results are returned.</li>
</ol>
<p>Of course, while these steps are common to all database engines, the way they are implemented can vary significantly from one engine to another.</p>
<div
  style="width: 100%; max-width: 60%; margin: 0 auto; text-align: center;">
  <img src="overview.png" alt="Overview of the query execution process"
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <div style="margin-top: 0.5em;">
    <p style="font-style: italic;">Overview of the query execution process</p>
  </div>
  
</div>
<h2 id="sqlite-s-approach-to-query-optimization">SQLite's Approach to Query Optimization</h2>
<p>Because SQLite is open source and has a small codebase, it’s relatively easy to understand how it works. The query optimizer in SQLite might seem like a modest engine at first glance, but under the hood, it's a sophisticated piece of software that makes smart decisions to ensure your queries run efficiently.</p>
<p>SQLite's query optimizer uses several different strategies to optimize query performance:</p>
<ol>
<li>
<p><strong>Index Selection</strong>: SQLite intelligently selects the best indexes to speed up data retrieval. It considers various factors, such as the columns in the <code>WHERE</code> clause and the order in which they appear.</p>
</li>
<li>
<p><strong>Join Ordering</strong>: For queries that involve joins, SQLite tries to figure out the most efficient order to join the tables. It uses heuristics and statistics to make an educated guess that minimizes the computational cost.</p>
</li>
<li>
<p><strong>Subquery Flattening</strong>: SQLite tries to flatten subqueries, meaning it attempts to merge subqueries into the main query whenever possible. This reduces the overhead of executing multiple queries separately.</p>
</li>
<li>
<p><strong>Covering Indexes</strong>: If an index contains all the columns needed by the query, SQLite can retrieve the results directly from the index without accessing the actual table, significantly speeding up the query.</p>
</li>
<li>
<p><strong>Cost Estimation</strong>: SQLite uses a cost-based query planner, which estimates the cost of different execution plans and chooses the one with the lowest estimated cost. The cost is generally a measure of how much disk I/O and CPU time will be consumed.</p>
</li>
</ol>
<p>These strategies help SQLite balance efficiency and performance, making it an excellent choice for applications where lightweight and quick database operations are essential.</p>
<h2 id="simple-example-query">Simple Example Query</h2>
<p>Now that we have a basic understanding of how SQLite's query optimizer works, let's take a look at a simple example query and see how it's optimized.</p>
<p>Borrowing from the Rice University legend, Dr. Christopher Jermaine, let's say we have the following relational schema:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">CREATE TABLE </span><span style="color:#5cb3fa;">LIKES</span><span style="color:#abb2bf;"> (
</span><span style="color:#abb2bf;">    DRINKER </span><span style="color:#cd74e8;">TEXT</span><span style="color:#abb2bf;">,
</span><span style="color:#abb2bf;">    BEER </span><span style="color:#cd74e8;">TEXT
</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="font-style:italic;color:#5f697a;">-- Example data
</span><span style="color:#cd74e8;">INSERT INTO</span><span style="color:#abb2bf;"> LIKES (DRINKER, BEER) </span><span style="color:#cd74e8;">VALUES
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Ava&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Bud Light&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Ava&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Pabst&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Ava&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Miller Lite&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Bob&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Bud Light&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Bob&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Coors Light&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Bob&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Miller Lite&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Charlie&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Bud Light&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Charlie&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Coors Light&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&#39;Charlie&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Miller Lite&#39;</span><span style="color:#abb2bf;">);
</span></code></pre>
<p>For demonstration, I'll be using the <a href="https://sqliteonline.com/">SQLite Online Compiler</a> to run the queries. Suppose we want to find all the beers that Ava likes with the following query:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">SELECT</span><span style="color:#abb2bf;"> BEER </span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> LIKES </span><span style="color:#cd74e8;">WHERE</span><span style="color:#abb2bf;"> DRINKER </span><span style="color:#adb7c9;">= </span><span style="color:#9acc76;">&#39;Ava&#39;</span><span style="color:#abb2bf;">;
</span></code></pre>
<div
  style="width: 100%; max-width: 80%; margin: 0 auto; text-align: center;">
  <img src="run-simple.png" alt="Running the simple query"
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <div style="margin-top: 0.5em;">
    <p style="font-style: italic;">Results of the simple query</p>
  </div>
  
</div>
<p>As we can see, we get the expected results for this query. But how does SQLite's query optimizer actually execute this query?</p>
<h3 id="analyzing-the-query-breaking-down-sqlite-s-execution-process">Analyzing the Query: Breaking Down SQLite's Execution Process</h3>
<h4 id="1-parsing-the-query">1. <strong>Parsing the Query</strong></h4>
<p>The first thing SQLite does is parse the SQL statement. The parser checks the query for any syntax errors and builds a parse tree—a hierarchical representation of the query. This step ensures that the SQL statement is valid and prepares it for further processing.</p>
<h4 id="2-generating-the-execution-plan">2. <strong>Generating the Execution Plan</strong></h4>
<p>After parsing, SQLite moves on to the query planning phase, where it generates an execution plan. An execution plan is a step-by-step roadmap of how SQLite will retrieve the data. This involves several key decisions:</p>
<div class="note-container" style="border:  1px solid #e0e0e0">
  
    

    <div class="note-content">
      <ul>
<li>
<p><strong>Table Access Method</strong>: SQLite needs to decide how to access the <code>LIKES</code> table. Since the <code>WHERE</code> clause filters rows based on the <code>DRINKER</code> column, SQLite considers whether there's an index on <code>DRINKER</code> that can speed up the retrieval.</p>
</li>
<li>
<p><strong>Index Usage</strong>: If there were an index on the <code>DRINKER</code> column, SQLite might use it to directly look up rows where <code>DRINKER = 'Ava'</code>. However, in this case, there’s no such index, so SQLite will perform a <strong>full table scan</strong>.</p>
</li>
</ul>

    </div>
    
  </div>
<p>We can inspect the execution plan using the <code>EXPLAIN QUERY PLAN</code> command:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="font-style:italic;color:#5f697a;">-- Explain query plan
</span><span style="color:#abb2bf;">EXPLAIN QUERY PLAN
</span><span style="color:#cd74e8;">SELECT</span><span style="color:#abb2bf;"> BEER </span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> LIKES </span><span style="color:#cd74e8;">WHERE</span><span style="color:#abb2bf;"> DRINKER </span><span style="color:#adb7c9;">= </span><span style="color:#9acc76;">&#39;Ava&#39;</span><span style="color:#abb2bf;">;
</span></code></pre>
<p>As expected since there's no index on the <code>DRINKER</code> column, the output is:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">SCAN LIKES
</span></code></pre>
<h4 id="3-full-table-scan-explained">3. <strong>Full Table Scan Explained</strong></h4>
<p>The plan indicates &quot;SCAN LIKES,&quot; meaning SQLite will read through the entire <code>LIKES</code> table, row by row, to find matches where <code>DRINKER = 'Ava'</code>. Here’s how it works:</p>
<div class="note-container" style="border:  1px solid #e0e0e0">
  
    

    <div class="note-content">
      <ul>
<li>SQLite starts at the first row of the <code>LIKES</code> table and checks if the <code>DRINKER</code> column equals 'Ava'.</li>
<li>If it matches, SQLite includes the <code>BEER</code> column from that row in the result set.</li>
<li>This process repeats for every row in the table.</li>
</ul>

    </div>
    
  </div>
<p>Even though a full table scan is the least efficient method (especially with large tables), it’s the only option when no suitable index is available. For small tables like our example, the performance impact is minimal, but with larger datasets, this could become a bottleneck.</p>
<h4 id="4-using-rowid-lookups-for-efficiency">4. <strong>Using Rowid Lookups for Efficiency</strong></h4>
<p>While full table scans are sometimes necessary, SQLite often relies on <strong>rowid lookups</strong> to speed up queries when no more specific index is available. Each table in SQLite has a unique identifier for each row called the <code>rowid</code>. If your query involves this <code>rowid</code> directly, SQLite can perform a binary search on this identifier, which is significantly faster than a full table scan.</p>
<p>For example, consider the following query:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">SELECT</span><span style="color:#abb2bf;"> BEER </span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> LIKES </span><span style="color:#cd74e8;">WHERE</span><span style="color:#abb2bf;"> rowid </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">;
</span></code></pre>
<p>In this case, SQLite will directly use the rowid to locate the record, bypassing the need to scan every row in the table. This technique can be particularly useful when you know the specific <code>rowid</code> of the data you need to retrieve.</p>
<h4 id="5-execution-returning-the-results">5. <strong>Execution: Returning the Results</strong></h4>
<p>Once the execution plan is ready, SQLite moves to the execution phase. The database engine follows the plan, scanning the <code>LIKES</code> table, filtering rows, and collecting the <code>BEER</code> values where <code>DRINKER</code> is 'Ava'. The results are then returned to the user.</p>
<p>In this simple case, the query returns:</p>
<div class="note-container" style="border:  1px solid #e0e0e0">
  
    

    <div class="note-content">
      <p>Bud Light</p>
<p>Pabst</p>
<p>Miller Lite</p>

    </div>
    
  </div>
<p>These results match what we expected because the query is straightforward and the table is small.</p>
<h4 id="6-optimizing-the-query-the-what-if-scenario">6. <strong>Optimizing the Query (The What-If Scenario)</strong></h4>
<p>Let’s imagine we want to optimize this query. The most effective way would be to create an index on the <code>DRINKER</code> column. With an index, SQLite could:</p>
<ul>
<li><strong>Skip the Full Table Scan</strong>: Instead of scanning the entire table, SQLite could directly jump to the rows where <code>DRINKER = 'Ava'</code>, significantly speeding up the query.</li>
</ul>
<p>Here’s how you could create the index:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">CREATE INDEX </span><span style="color:#abb2bf;">idx_drinker ON </span><span style="color:#5cb3fa;">LIKES</span><span style="color:#abb2bf;">(DRINKER);
</span></code></pre>
<p>With this index, if you run the same query again:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">SELECT</span><span style="color:#abb2bf;"> BEER </span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> LIKES </span><span style="color:#cd74e8;">WHERE</span><span style="color:#abb2bf;"> DRINKER </span><span style="color:#adb7c9;">= </span><span style="color:#9acc76;">&#39;Ava&#39;</span><span style="color:#abb2bf;">;
</span></code></pre>
<p>SQLite would use the index to find all rows with <code>DRINKER = 'Ava'</code> directly, reducing the amount of work it needs to do.</p>
<p>Now when we <code>EXPLAIN QUERY PLAN</code> command to inspect how SQLite would handle the query now, we see:</p>
<pre style="background-color:#2b303b;color:#6c7079;"><code><span style="color:#abb2bf;">SEARCH LIKES USING INDEX idx_drinker (DRINKER=?)
</span></code></pre>
<p>This indicates that SQLite is now using the <code>idx_drinker</code> index to perform a much faster search. Instead of scanning the entire table, it quickly narrows down the relevant rows using the index, demonstrating a significant improvement in query performance.</p>
<h4 id="takeaways-from-the-simple-query-example">Takeaways from the Simple Query Example</h4>
<p>This simple example highlights how SQLite’s query optimizer works in the background to execute SQL queries efficiently. While a full table scan might be acceptable in small tables, as your data grows, understanding and utilizing indexes can make a world of difference in performance.</p>
<p>Even in this simple query, we've uncovered the critical role the query planner plays in determining how to retrieve your data efficiently, and how small changes—like adding an index—can lead to significant performance gains.</p>
<p>In the next sections, we’ll dive deeper into more complex queries and see how SQLite handles more challenging scenarios, giving you the tools to write even more efficient SQL code.</p>
<hr />
<h2 id="complex-query-example-getting-to-the-heart-of-the-optimizer">Complex Query Example: Getting to the Heart of the Optimizer</h2>
<p>Now that we’ve covered the basics, let’s look at a more complicated query that gives SQLite’s optimizer something to chew on.</p>
<p>Imagine we have two tables, <code>DRINKER</code> and <code>BEER</code>, and we want to perform a query that joins them to find out which beers each drinker likes, sorted by their preference. The schema might look something like this:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">CREATE TABLE </span><span style="color:#5cb3fa;">DRINKER</span><span style="color:#abb2bf;"> (
</span><span style="color:#abb2bf;">    ID </span><span style="color:#cd74e8;">INTEGER PRIMARY KEY</span><span style="color:#abb2bf;">,
</span><span style="color:#abb2bf;">    NAME </span><span style="color:#cd74e8;">TEXT
</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">CREATE TABLE </span><span style="color:#5cb3fa;">BEER</span><span style="color:#abb2bf;"> (
</span><span style="color:#abb2bf;">    ID </span><span style="color:#cd74e8;">INTEGER PRIMARY KEY</span><span style="color:#abb2bf;">,
</span><span style="color:#abb2bf;">    NAME </span><span style="color:#cd74e8;">TEXT</span><span style="color:#abb2bf;">,
</span><span style="color:#abb2bf;">    TYPE </span><span style="color:#cd74e8;">TEXT
</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">CREATE TABLE </span><span style="color:#5cb3fa;">LIKES</span><span style="color:#abb2bf;"> (
</span><span style="color:#abb2bf;">    DRINKER_ID </span><span style="color:#cd74e8;">INTEGER</span><span style="color:#abb2bf;">,
</span><span style="color:#abb2bf;">    BEER_ID </span><span style="color:#cd74e8;">INTEGER</span><span style="color:#abb2bf;">,
</span><span style="color:#abb2bf;">    PREFERENCE </span><span style="color:#cd74e8;">INTEGER</span><span style="color:#abb2bf;">, </span><span style="font-style:italic;color:#5f697a;">-- Lower numbers indicate higher preference
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">FOREIGN KEY</span><span style="color:#abb2bf;">(DRINKER_ID) </span><span style="color:#cd74e8;">REFERENCES</span><span style="color:#abb2bf;"> DRINKER(ID),
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">FOREIGN KEY</span><span style="color:#abb2bf;">(BEER_ID) </span><span style="color:#cd74e8;">REFERENCES</span><span style="color:#abb2bf;"> BEER(ID)
</span><span style="color:#abb2bf;">);
</span></code></pre>
<p>And let's populate the tables with some example data:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="font-style:italic;color:#5f697a;">-- Example data
</span><span style="color:#cd74e8;">INSERT INTO</span><span style="color:#abb2bf;"> DRINKER (ID, NAME) </span><span style="color:#cd74e8;">VALUES
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Alice&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Bob&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Charlie&#39;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">INSERT INTO</span><span style="color:#abb2bf;"> BEER (ID, NAME, TYPE) </span><span style="color:#cd74e8;">VALUES
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Budweiser&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Lager&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Coors Light&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Lager&#39;</span><span style="color:#abb2bf;">),
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Miller Lite&#39;</span><span style="color:#abb2bf;">, </span><span style="color:#9acc76;">&#39;Pilsner&#39;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">INSERT INTO</span><span style="color:#abb2bf;"> LIKES (DRINKER_ID, BEER_ID, PREFERENCE) </span><span style="color:#cd74e8;">VALUES
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">),  </span><span style="font-style:italic;color:#5f697a;">-- Alice likes Budweiser the most
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">),  </span><span style="font-style:italic;color:#5f697a;">-- Alice likes Coors Light second
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">),  </span><span style="font-style:italic;color:#5f697a;">-- Bob prefers Miller Lite
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">1</span><span style="color:#abb2bf;">),  </span><span style="font-style:italic;color:#5f697a;">-- Charlie likes Budweiser the most
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">),  </span><span style="font-style:italic;color:#5f697a;">-- Charlie&#39;s least favorite is Coors Light
</span><span style="color:#abb2bf;">(</span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">3</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">2</span><span style="color:#abb2bf;">);  </span><span style="font-style:italic;color:#5f697a;">-- Charlie likes Miller Lite second
</span></code></pre>
<p>Now, suppose we want to find out which beers each drinker likes, sorted by their preference:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">SELECT </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">BEER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">PREFERENCE
</span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> DRINKER
</span><span style="color:#cd74e8;">JOIN</span><span style="color:#abb2bf;"> LIKES ON </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">ID </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">DRINKER_ID
</span><span style="color:#cd74e8;">JOIN</span><span style="color:#abb2bf;"> BEER ON </span><span style="color:#db9d63;">BEER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">ID </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">BEER_ID
</span><span style="color:#cd74e8;">ORDER BY </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">PREFERENCE</span><span style="color:#abb2bf;">;
</span></code></pre>
<p>This query isn’t as simple as it looks. SQLite’s optimizer has to decide:</p>
<ol>
<li><strong>Join Order</strong>: Should it start with the <code>DRINKER</code>, <code>LIKES</code>, or <code>BEER</code> table?</li>
<li><strong>Index Usage</strong>: Which indexes, if any, can be used to speed up the joins and the sorting?</li>
<li><strong>Sorting</strong>: How should the results be sorted efficiently after the joins?</li>
</ol>
<h3 id="understanding-the-query-plan-what-happens-behind-the-scenes">Understanding the Query Plan: What Happens Behind the Scenes</h3>
<p>When we look at the query plan for the complex query:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">EXPLAIN QUERY PLAN
</span><span style="color:#cd74e8;">SELECT </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">BEER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">PREFERENCE
</span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> DRINKER
</span><span style="color:#cd74e8;">JOIN</span><span style="color:#abb2bf;"> LIKES ON </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">ID </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">DRINKER_ID
</span><span style="color:#cd74e8;">JOIN</span><span style="color:#abb2bf;"> BEER ON </span><span style="color:#db9d63;">BEER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">ID </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">BEER_ID
</span><span style="color:#cd74e8;">ORDER BY </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">PREFERENCE</span><span style="color:#abb2bf;">;
</span></code></pre>
<p>We get the following output:</p>
<div class="note-container" style="border:  1px solid #e0e0e0">
  
    

    <div class="note-content">
      <p>SCAN LIKES</p>
<p>SEARCH DRINKER USING INTEGER PRIMARY KEY (rowid=?)</p>
<p>SEARCH BEER USING INTEGER PRIMARY KEY (rowid=?)</p>
<p>USE TEMP B-TREE FOR ORDER BY</p>

    </div>
    
  </div>
<p>This output provides a high-level overview of how SQLite intends to execute the query. Let’s break down each component and understand what’s happening under the hood.</p>
<h4 id="1-scan-the-likes-table">1. <strong>Scan the <code>LIKES</code> Table</strong></h4>
<ul>
<li><strong>Plan Step</strong>: <code>SCAN LIKES</code></li>
</ul>
<p>SQLite begins by scanning the <code>LIKES</code> table. Since <code>LIKES</code> is the central table in this query, containing the foreign keys that link <code>DRINKER</code> to <code>BEER</code>, it makes sense for SQLite to start here.</p>
<ul>
<li><strong>Why a Table Scan?</strong>: The plan shows that SQLite performs a full table scan on <code>LIKES</code>, meaning it reads every row in the table. This might seem inefficient, but without specific indexes on <code>DRINKER_ID</code> or <code>BEER_ID</code>, a full scan is necessary to gather all the relevant data.</li>
</ul>
<h4 id="2-searching-the-drinker-and-beer-tables">2. <strong>Searching the <code>DRINKER</code> and <code>BEER</code> Tables</strong></h4>
<div class="note-container" style="border:  1px solid #e0e0e0">
  
    

    <div class="note-content">
      <ul>
<li><strong>Plan Steps</strong>:
<ul>
<li><code>SEARCH DRINKER USING INTEGER PRIMARY KEY (rowid=?)</code></li>
<li><code>SEARCH BEER USING INTEGER PRIMARY KEY (rowid=?)</code></li>
</ul>
</li>
</ul>

    </div>
    
  </div>
<p>For each row in <code>LIKES</code>, SQLite needs to find the corresponding <code>DRINKER</code> and <code>BEER</code> entries. It uses the primary key indexes (<code>INTEGER PRIMARY KEY</code>) on these tables to quickly locate the matching rows.</p>
<ul>
<li><strong>Primary Key Lookup</strong>: Because both <code>DRINKER.ID</code> and <code>BEER.ID</code> are defined as primary keys, SQLite can perform an efficient lookup using these indexes. The query plan indicates that for each <code>LIKES</code> entry, SQLite performs a quick search in both <code>DRINKER</code> and <code>BEER</code> tables to retrieve the <code>NAME</code> fields.</li>
</ul>
<h4 id="3-using-a-temporary-b-tree-for-sorting">3. <strong>Using a Temporary B-Tree for Sorting</strong></h4>
<ul>
<li><strong>Plan Step</strong>: <code>USE TEMP B-TREE FOR ORDER BY</code></li>
</ul>
<p>The final step in the query plan involves sorting the results. The query requests that the results be ordered by <code>DRINKER.NAME</code> and <code>LIKES.PREFERENCE</code>. Since the data isn’t naturally ordered in this way, SQLite must perform additional work to achieve this sort order.</p>
<ul>
<li>
<p><strong>Temporary B-Tree</strong>: To sort the results efficiently, SQLite creates a temporary B-tree structure. A B-tree is a self-balancing tree data structure that maintains sorted data and allows for efficient insertion, deletion, and lookup operations. By inserting the result set into this B-tree, SQLite can quickly and efficiently retrieve the data in the desired order.</p>
</li>
<li>
<p><strong>Why Not an Index?</strong>: The need for a temporary B-tree indicates that there isn’t an existing index that supports the required sort order. This extra step adds overhead, which is why creating an appropriate index can be beneficial.</p>
</li>
</ul>
<p>Combining all these steps, we get the expected output:</p>
<div
  style="width: 100%; max-width: 80%; margin: 0 auto; text-align: center;">
  <img src="run-complex.png" alt="Running the complex query"
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <div style="margin-top: 0.5em;">
    <p style="font-style: italic;">Results of the complex query</p>
  </div>
  
</div>
<br>
<h3 id="optimizing-the-query-adding-a-multi-column-index">Optimizing the Query: Adding a Multi-Column Index</h3>
<p>As mentioned earlier, one way to improve this query's performance is by adding an index on the <code>LIKES</code> table. Specifically, creating a <strong>multi-column index</strong> on the combination of <code>DRINKER_ID</code> and <code>PREFERENCE</code> would directly support the sorting required by the query:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">CREATE INDEX </span><span style="color:#abb2bf;">idx_likes_drinker_pref ON </span><span style="color:#5cb3fa;">LIKES</span><span style="color:#abb2bf;">(DRINKER_ID, PREFERENCE);
</span></code></pre>
<p>By creating this multi-column index, SQLite can:</p>
<ul>
<li>
<p><strong>Avoid Full Table Scans</strong>: With this index, SQLite can avoid a full scan of the <code>LIKES</code> table. Instead, it can directly jump to the relevant rows using the index, which is more efficient.</p>
</li>
<li>
<p><strong>Optimize Sorting</strong>: The index also covers the <code>PREFERENCE</code> column, which means the results can be retrieved in the correct order directly from the index. This eliminates the need for a temporary B-tree, reducing the query’s overall execution time.</p>
</li>
</ul>
<div
  style="width: 100%; max-width: 80%; margin: 0 auto; text-align: center;">
  <img src="multicolumn-idx.png" alt="Example multicolumn index from the SQLite query planner documentation illustrating a lookup using the index"
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <div style="margin-top: 0.5em;">
    <p style="font-style: italic;">Example multicolumn index from the SQLite query planner documentation illustrating a lookup using the index.</p>
  </div>
  
</div>
<h3 id="re-running-the-query-plan">Re-running the Query Plan</h3>
<p>After creating the index, if we re-run the <code>EXPLAIN QUERY PLAN</code> command, we might see a different plan:</p>
<pre data-lang="sql" style="background-color:#2b303b;color:#6c7079;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">EXPLAIN QUERY PLAN
</span><span style="color:#cd74e8;">SELECT </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">BEER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">PREFERENCE
</span><span style="color:#cd74e8;">FROM</span><span style="color:#abb2bf;"> DRINKER
</span><span style="color:#cd74e8;">JOIN</span><span style="color:#abb2bf;"> LIKES ON </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">ID </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">DRINKER_ID
</span><span style="color:#cd74e8;">JOIN</span><span style="color:#abb2bf;"> BEER ON </span><span style="color:#db9d63;">BEER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">ID </span><span style="color:#adb7c9;">= </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">BEER_ID
</span><span style="color:#cd74e8;">ORDER BY </span><span style="color:#db9d63;">DRINKER</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">NAME</span><span style="color:#abb2bf;">, </span><span style="color:#db9d63;">LIKES</span><span style="color:#abb2bf;">.</span><span style="color:#db9d63;">PREFERENCE</span><span style="color:#abb2bf;">;
</span></code></pre>
<p>The updated plan now reflects the use of the new index:</p>
<div class="note-container" style="border:  1px solid #e0e0e0">
  
    

    <div class="note-content">
      <p>SCAN DRINKER
SEARCH LIKES USING INDEX idx_likes_drinker_pref (DRINKER_ID=?)
SEARCH BEER USING INTEGER PRIMARY KEY (rowid=?)
USE TEMP B-TREE FOR ORDER BY</p>

    </div>
    
  </div>
<p>This new execution plan reflects several optimizations made by SQLite:</p>
<ol>
<li>
<p><strong>SCAN DRINKER</strong>:</p>
<ul>
<li>SQLite starts by scanning the <code>DRINKER</code> table. Since this is a full table scan, it reads each row from the <code>DRINKER</code> table sequentially. This step makes sense as it’s the starting point of our query, and no filters or constraints are applied to <code>DRINKER</code> that would allow an index to be used here.</li>
</ul>
</li>
<li>
<p><strong>SEARCH LIKES USING INDEX <code>idx_likes_drinker_pref</code> (DRINKER_ID=?)</strong>:</p>
<ul>
<li>Here’s where the optimization kicks in. SQLite uses the newly created index <code>idx_likes_drinker_pref</code> on the <code>LIKES</code> table. This index is likely created on the <code>DRINKER_ID</code> and <code>PREFERENCE</code> columns, allowing SQLite to efficiently find the rows in <code>LIKES</code> where <code>DRINKER_ID</code> matches the current row from the <code>DRINKER</code> table. This dramatically reduces the amount of data SQLite needs to sift through compared to a full table scan.</li>
</ul>
</li>
<li>
<p><strong>SEARCH BEER USING INTEGER PRIMARY KEY (rowid=?)</strong>:</p>
</li>
</ol>
<ul>
<li>For the <code>BEER</code> table, SQLite utilizes the primary key index, which is an automatically created index on the <code>ID</code> column (which acts as the <code>rowid</code>). Since this is the most efficient way to retrieve specific rows from <code>BEER</code>, SQLite uses this index to quickly find the beer names corresponding to the <code>BEER_ID</code> values from the <code>LIKES</code> table.</li>
</ul>
<ol start="4">
<li><strong>USE TEMP B-TREE FOR ORDER BY</strong>:
<ul>
<li>Finally, SQLite notes that it will use a temporary B-Tree to sort the results according to the <code>ORDER BY</code> clause (<code>DRINKER.NAME</code> and <code>LIKES.PREFERENCE</code>). Even though indexes can often help with sorting, in this case, SQLite decides to use a temporary B-Tree structure to ensure that the results are returned in the correct order. This step can be a bit more resource-intensive, but it guarantees that the results will be sorted as requested.</li>
</ul>
</li>
</ol>
<p>The use of the <code>idx_likes_drinker_pref</code> index significantly improves the efficiency of the query. By avoiding a full table scan on <code>LIKES</code>, SQLite reduces the amount of data it needs to process, which speeds up query execution, especially on larger datasets.</p>
<p>The final <code>ORDER BY</code> clause requires SQLite to sort the results, and since the current indexes do not cover both <code>DRINKER.NAME</code> and <code>LIKES.PREFERENCE</code>, SQLite opts to use a temporary B-Tree. If you frequently run this query and notice the sorting step is a bottleneck, you could consider creating a composite index on these two columns to further optimize performance.</p>
<hr />
<h2 id="conclusion-tips-for-writing-efficient-queries">Conclusion: Tips for Writing Efficient Queries</h2>
<p>By peeking under the hood at how SQL queries are executed, you can gain some intuition on why certain queries are faster than others. Here are a few tips to keep in mind:</p>
<ol>
<li>
<p><strong>Index Your Foreign Keys</strong>: Always create indexes on columns used in <code>JOIN</code> conditions. This speeds up the process of matching rows between tables.</p>
</li>
<li>
<p><strong>Use Covering Indexes</strong>: If possible, create indexes that cover all the columns your query needs, so SQLite doesn’t need to access the main table at all.</p>
</li>
<li>
<p><strong>Write Selective WHERE Clauses</strong>: If your <code>WHERE</code> clause can quickly eliminate rows from consideration, your query will run faster. The fewer rows SQLite has to process, the better.</p>
</li>
<li>
<p><strong>Avoid Redundant Sorting</strong>: If you know your data is already sorted in the way you want, avoid using <code>ORDER BY</code>. It just adds unnecessary processing time.</p>
</li>
<li>
<p><strong>Optimize Subqueries</strong>: Subqueries can sometimes be rewritten as joins, which might be more efficient, especially if the subquery’s result set is large.</p>
</li>
<li>
<p><strong>Understand the Query Planner</strong>: Use tools like <code>EXPLAIN QUERY PLAN</code> to understand how SQLite executes your queries. Sometimes, a small change in the query structure can lead to a big performance improvement.</p>
</li>
</ol>
<p>Learning to write efficient SQL queries is a valuable skill that translates across all database systems and can make a significant difference in your application’s performance, scalability, and resource usage. Like most things, it takes practice and experimentation and this post just scratches the surface of optimizing queries. If you have any tips or tricks for optimizing SQL queries, feel free to share them in the comments!</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://gist.github.com/micahkepe/f9035bf308510b11482d1643b07ceaf7">Full SQL Script for the Examples</a></li>
<li><a href="https://www.sqlite.org/optoverview.html">The SQLite Query Optimizer Overview</a></li>
<li><a href="https://www.sqlite.org/queryplanner.html">SQLite Query Planner</a></li>
<li><a href="https://www.sqlite.org/queryplanner-ng.html">The Next-Generation Query Planner</a></li>
<li><a href="https://www.geeksforgeeks.org/order-of-execution-of-sql-queries/">Order of Execution of SQL Queries</a></li>
</ul>
<script
  src="https://utteranc.es/client.js"
  repo="micahkepe/micahkepe.github.io"
  issue-term="pathname"
  label="comment-section"
  theme="github-dark"
  crossorigin="anonymous"
  async
></script>

    </div>

    
        <footer>
            <hr>
            <p>
                
                    Published by Micah Kepe
                
                
                    
                    in <a href="https://micahkepe.com/blog/categories/programming/">programming</a>
                
                
                    and
                    tagged
                    
                        <a href="https://micahkepe.com/blog/tags/databases/">databases</a>
                        
                            
                                
                                    ,
                                
                            
                        
                    
                        <a href="https://micahkepe.com/blog/tags/sqlite/">sqlite</a>
                        
                            
                                
                                    and
                                
                            
                        
                    
                        <a href="https://micahkepe.com/blog/tags/query-optimizer/">query-optimizer</a>
                        
                            
                        
                    
                
            </p>
            
            
        </footer>
    
</article>



  <!-- optional scripts -->
  
  
  <script src="https://micahkepe.com/blog/js/codeblock.js"></script>
  

  
<!-- MathJax script for rendering LaTeX math equations -->
<script>
  MathJax = {
    tex: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"],
      ],
      displayMath: [
        ["$$", "$$"],
        ["\\[", "\\]"],
      ],
    },
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>


  


  
</body>

</html>
